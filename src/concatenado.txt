AreaDetailScreen.tsx:
import React from 'react';
import { View, Text, StyleSheet, ScrollView, TouchableOpacity } from 'react-native';
import { useRoute, useNavigation } from '@react-navigation/native'; // <-- 1. Importar useNavigation
import { Area, Puerta } from '../types/entities';
import MapView, { Marker, PROVIDER_GOOGLE } from 'react-native-maps'; 
import { Ionicons } from '@expo/vector-icons';

// --- Tipos de Navegación ---
import { NativeStackNavigationProp } from '@react-navigation/native-stack';
import { RootStackParamList } from '../types/navigation';
type AreaDetailNavigationProp = NativeStackNavigationProp<RootStackParamList, 'RouteMap'>;

// --- Componente de Tarjeta de Puerta ACTUALIZADO ---
const PuertaCard = ({ puerta }: { puerta: Puerta }) => {
  const navigation = useNavigation<AreaDetailNavigationProp>(); // <-- 2. Obtener navegación

  const disponibles = puerta.cuposTotales - puerta.cuposOcupados;
  const isOpen = puerta.status === 'OPEN';
  const hasCupos = disponibles > 0;
  
  // --- 3. Lógica del botón ---
  const isButtonDisabled = !isOpen || !hasCupos;

  const color = isOpen && hasCupos ? '#2E8B57' : (isOpen ? '#FFA500' : '#DC143C');

  const handlePress = () => {
    if (!isButtonDisabled) {
      navigation.navigate('RouteMap', { puerta: puerta });
    }
  };

  return (
    <View style={[styles.puertaCard, { borderColor: color }]}>
      <View style={styles.puertaInfo}>
        <Text style={styles.puertaName}>{puerta.nombre}</Text>
        {isOpen ? (
          <Text style={[styles.cuposText, { color: color }]}>
            {disponibles} / {puerta.cuposTotales} disponibles
          </Text>
        ) : (
          <Text style={styles.cuposTextCerrado}>
            Cerrada ({puerta.status})
          </Text>
        )}
      </View>
      
      {/* --- 4. Botón "Trazar Ruta" --- */}
      <TouchableOpacity 
        style={[styles.routeButton, isButtonDisabled && styles.routeButtonDisabled]}
        disabled={isButtonDisabled}
        onPress={handlePress}
      >
        <Ionicons name="map-outline" size={20} color={isButtonDisabled ? '#999' : '#0066CC'} />
        <Text style={[styles.routeButtonText, isButtonDisabled && styles.routeButtonTextDisabled]}>
          Ruta
        </Text>
      </TouchableOpacity>
    </View>
  );
};
// --- Fin PuertaCard ---


export default function AreaDetailScreen() {
  const route = useRoute();
  // @ts-ignore
  const { area } = route.params as { area: Area };

  const initialRegion = {
    latitude: area.latitude,
    longitude: area.longitude,
    latitudeDelta: area.latitudeDelta,
    longitudeDelta: area.longitudeDelta,
  };

  return (
    <ScrollView style={styles.container}>
      <View style={styles.header}>
        <Text style={styles.title}>{area.nombre}</Text>
        <Text style={styles.subtitle}>Estado de accesos y mapa</Text>
      </View>

      <MapView
        // ... (el mapa no cambia)
        style={styles.map}
        provider={PROVIDER_GOOGLE}
        initialRegion={initialRegion}
        showsUserLocation
        showsMyLocationButton
      >
        {area.puertas.map(puerta => (
          <Marker
            key={puerta.id}
            coordinate={{
              latitude: puerta.latitude,
              longitude: puerta.longitude,
            }}
            title={puerta.nombre}
            description={`Cupos: ${puerta.cuposOcupados}/${puerta.cuposTotales}`}
            pinColor={puerta.status === 'OPEN' && puerta.cuposOcupados < puerta.cuposTotales ? 'green' : (puerta.status === 'OPEN' ? 'orange' : 'red')}
          />
        ))}
      </MapView>
      
      <View style={styles.puertasSection}>
        <Text style={styles.sectionTitle}>Accesos Vehiculares</Text>
        {area.puertas.map(puerta => (
          <PuertaCard key={puerta.id} puerta={puerta} />
        ))}
      </View>
    </ScrollView>
  );
}

// --- Estilos Actualizados ---
const styles = StyleSheet.create({
  // ... (container, header, title, subtitle, map... no cambian)
  container: { flex: 1, backgroundColor: '#f5f5f5' },
  header: { backgroundColor: '#ffffff', paddingVertical: 24, paddingHorizontal: 20, alignItems: 'center', borderBottomWidth: 1, borderBottomColor: '#eee' },
  title: { fontSize: 28, fontWeight: 'bold', color: '#0066CC' },
  subtitle: { fontSize: 16, color: '#555', marginTop: 4 },
  map: { height: 300, margin: 20, borderRadius: 12 },
  puertasSection: { paddingHorizontal: 20, paddingBottom: 20 },
  sectionTitle: { fontSize: 20, fontWeight: '600', color: '#333', marginBottom: 16 },

  puertaCard: {
    backgroundColor: '#fff',
    borderRadius: 8,
    padding: 16,
    marginBottom: 12,
    borderLeftWidth: 5,
    flexDirection: 'row', // <-- 5. Alineación horizontal
    justifyContent: 'space-between',
    alignItems: 'center',
  },
  puertaInfo: {
    flex: 1, // Permite que el texto se ajuste
  },
  puertaName: {
    fontSize: 16,
    fontWeight: '500',
    color: '#333',
  },
  cuposText: {
    fontSize: 18,
    fontWeight: 'bold',
    marginTop: 8,
  },
  cuposTextCerrado: {
    fontSize: 16,
    fontWeight: '500',
    marginTop: 8,
    color: '#777',
    fontStyle: 'italic',
  },
  
  // --- 6. Estilos para el nuevo botón ---
  routeButton: {
    flexDirection: 'row',
    alignItems: 'center',
    backgroundColor: '#f0f5ff',
    paddingHorizontal: 12,
    paddingVertical: 10,
    borderRadius: 20,
    gap: 6,
    borderWidth: 1,
    borderColor: '#0066CC'
  },
  routeButtonDisabled: {
    backgroundColor: '#f5f5f5',
    borderColor: '#ddd'
  },
  routeButtonText: {
    color: '#0066CC',
    fontSize: 14,
    fontWeight: '600',
  },
  routeButtonTextDisabled: {
    color: '#999',
  }
});

HistorialScreen.tsx:
import React, { useEffect, useState, useMemo } from 'react';
import {
  View, Text, StyleSheet, SectionList,
  ActivityIndicator, StatusBar, Button,
  ScrollView, TouchableOpacity,
  Image 
} from 'react-native';
import ParkingService from '../services/ParkingService';
import { HistoryItem } from '../types/entities';
import { Ionicons } from '@expo/vector-icons';
import DateTimePickerModal from "react-native-modal-datetime-picker";

// --- Tipos y Constantes (no cambian) ---
type HistoryFilter = 'today' | 'week' | 'month' | 'all';
const FILTERS: { id: HistoryFilter, label: string }[] = [
  { id: 'all', label: 'Todos' },
  { id: 'today', label: 'Hoy' },
  { id: 'week', label: 'Esta Semana' },
  { id: 'month', label: 'Este Mes' },
];

// --- HistoryEntry (con ícono de carro) ---
const HistoryEntry = ({ item }: { item: HistoryItem }) => (
  <View style={styles.entryCard}>
    <Image 
      source={require('../../assets/carro.png')} 
      style={styles.entryIcon} 
    />
    <View style={styles.entryDetails}>
      <Text style={styles.entryArea}>{item.area} ({item.puerta})</Text>
      <Text style={styles.entryTime}>
        {item.fechaEntrada.split(' ')[1]} - {item.fechaSalida ? item.fechaSalida.split(' ')[1] : 'Estacionado'}
      </Text>
    </View>
    <Text style={styles.entryPlaca}>{item.placa}</Text>
  </View>
);

// --- SectionHeader (no cambia) ---
const SectionHeader = ({ title }: { title: string }) => (
  <Text style={styles.sectionHeader}>{title}</Text>
);

// --- groupHistoryByDate (no cambia) ---
const groupHistoryByDate = (items: HistoryItem[]) => {
  const groups: { [key: string]: HistoryItem[] } = {};
  items.forEach(item => {
    const date = new Date(item.fechaEntrada);
    const dateString = date.toLocaleDateString('es-ES', { year: 'numeric', month: 'long', day: 'numeric' });
    const today = new Date();
    // const today = new Date('2025-11-10T10:00:00'); // Para probar MOCK
    const yesterday = new Date(today);
    yesterday.setDate(yesterday.getDate() - 1);
    let key = dateString;
    if (date.toDateString() === today.toDateString()) key = 'Hoy';
    else if (date.toDateString() === yesterday.toDateString()) key = 'Ayer';
    if (!groups[key]) groups[key] = [];
    groups[key].push(item);
  });
  return Object.keys(groups).map(key => ({ title: key, data: groups[key] }));
};


// --- 1. Componente de Filtros (MODIFICADO) ---
// Ahora SÓLO renderiza los chips de filtro rápido.
const FilterChips = ({ activeFilter, onSelectFilter }: {
  activeFilter: HistoryFilter | 'custom';
  onSelectFilter: (filter: HistoryFilter) => void;
}) => {
  return (
    <View style={styles.filterChipContainer}>
      <ScrollView horizontal showsHorizontalScrollIndicator={false}>
        {FILTERS.map(filter => {
          const isActive = filter.id === activeFilter;
          return (
            <TouchableOpacity
              key={filter.id}
              style={[styles.chip, isActive ? styles.chipActive : styles.chipInactive]}
              onPress={() => onSelectFilter(filter.id)}
            >
              <Text style={isActive ? styles.chipTextActive : styles.chipTextInactive}>
                {filter.label}
              </Text>
            </TouchableOpacity>
          );
        })}
        {/* El botón de calendario se movió al componente principal */}
      </ScrollView>
    </View>
  );
};


export default function HistorialScreen() {
  const [isLoading, setIsLoading] = useState(true);
  const [isLoadingMore, setIsLoadingMore] = useState(false);
  const [page, setPage] = useState(1);
  const [historyItems, setHistoryItems] = useState<HistoryItem[]>([]);
  const [allDataLoaded, setAllDataLoaded] = useState(false);
  
  const [filter, setFilter] = useState<HistoryFilter | 'custom'>('all');
  const [selectedDate, setSelectedDate] = useState<Date | null>(null);
  const [isDatePickerVisible, setDatePickerVisible] = useState(false);

  // --- Lógica de Carga de Datos (no cambia) ---
  const loadHistory = async (pageToLoad: number) => {
    if (allDataLoaded || isLoadingMore) return;
    if (pageToLoad === 1) setIsLoading(true);
    else setIsLoadingMore(true);
    try {
      const filterToSend = (filter === 'custom' && selectedDate) ? selectedDate : filter;
      // @ts-ignore
      const newData = await ParkingService.getUserHistory(pageToLoad, filterToSend);
      if (newData.length === 0) {
        setAllDataLoaded(true);
      } else {
        setHistoryItems(prevItems => 
          pageToLoad === 1 ? newData : [...prevItems, ...newData]
        );
        setPage(pageToLoad);
      }
    } catch (error) {
      console.error("Error cargando historial:", error);
    } finally {
      setIsLoading(false);
      setIsLoadingMore(false);
    }
  };

  // --- useEffect (no cambia) ---
  useEffect(() => {
    setPage(1);
    setHistoryItems([]);
    setAllDataLoaded(false);
    loadHistory(1);
  }, [filter, selectedDate]);

  // --- Funciones del Calendario (no cambian) ---
  const showDatePicker = () => { setDatePickerVisible(true); };
  const hideDatePicker = () => { setDatePickerVisible(false); };
  const handleConfirmDate = (date: Date) => {
    setFilter('custom');
    setSelectedDate(date);
    hideDatePicker();
  };
  
  // --- handleLoadMore (no cambia) ---
  const handleLoadMore = () => {
    if (!allDataLoaded && !isLoadingMore) {
      loadHistory(page + 1);
    }
  };

  // --- renderFooter (no cambia) ---
  const renderFooter = () => {
    if (isLoadingMore) {
      return <ActivityIndicator size="large" color="#0066CC" style={{ margin: 20 }} />;
    }
    if (allDataLoaded && historyItems.length > 0) {
      return <Text style={styles.footerText}>No hay más registros</Text>;
    }
    if (!allDataLoaded && historyItems.length > 0) {
      return (
        <View style={styles.footerButtonContainer}>
          <Button title="Cargar más registros" onPress={handleLoadMore} color="#0066CC" />
        </View>
      );
    }
    return null;
  };

  const groupedData = useMemo(() => groupHistoryByDate(historyItems), [historyItems]);

  // --- Renderizado Principal ---
  if (isLoading && page === 1) {
    // ... (igual que antes, muestra el cargando inicial)
    return (
      <View style={styles.container}>
        <Text style={styles.title}>Mi Historial</Text>
        {/* --- 2. RENDERIZADO DE FILTROS ACTUALIZADO --- */}
        <View style={styles.filterSection}>
          <FilterChips 
            activeFilter={filter} 
            onSelectFilter={setFilter} 
          />
          <TouchableOpacity style={styles.datePickerButton} onPress={showDatePicker}>
            <Text style={styles.datePickerText}>Buscar por fecha:</Text>
            <Ionicons name="calendar-outline" size={20} color={filter === 'custom' ? '#0066CC' : '#555'} />
          </TouchableOpacity>
        </View>
        <View style={styles.centerContainer}>
          <ActivityIndicator size="large" color="#0066CC" />
          <Text style={styles.loadingText}>Cargando historial...</Text>
        </View>
      </View>
    );
  }

  return (
    <View style={styles.container}>
      <StatusBar barStyle="dark-content" />
      <Text style={styles.title}>Mi Historial</Text>
      
      {/* --- 3. RENDERIZADO DE FILTROS ACTUALIZADO --- */}
      <View style={styles.filterSection}>
        <FilterChips 
          activeFilter={filter} 
          onSelectFilter={setFilter} 
        />
        <TouchableOpacity style={styles.datePickerButton} onPress={showDatePicker}>
          <Text style={styles.datePickerText}>Buscar por fecha:</Text>
          <Ionicons 
            name="calendar-outline" 
            size={20} 
            // El ícono se pone azul si el filtro 'custom' está activo
            color={filter === 'custom' ? '#0066CC' : '#555'} 
          />
        </TouchableOpacity>
      </View>
      
      <DateTimePickerModal
        isVisible={isDatePickerVisible}
        mode="date"
        onConfirm={handleConfirmDate}
        onCancel={hideDatePicker}
        maximumDate={new Date()} 
      />
      
      <SectionList
        sections={groupedData}
        keyExtractor={(item) => item.id}
        renderItem={({ item }) => <HistoryEntry item={item} />}
        renderSectionHeader={({ section: { title } }) => <SectionHeader title={title} />}
        ListFooterComponent={renderFooter}
        ListEmptyComponent={
          !isLoading ? (
            <View style={styles.centerContainer}>
              <Text style={styles.footerText}>No se encontraron registros para este filtro.</Text>
            </View>
          ) : null
        }
        contentContainerStyle={styles.list}
      />
    </View>
  );
}

// --- 4. ESTILOS ACTUALIZADOS ---
const styles = StyleSheet.create({
  centerContainer: { flex: 1, justifyContent: 'center', alignItems: 'center', padding: 20, backgroundColor: '#f5f5f5', },
  loadingText: { marginTop: 10, fontSize: 16, color: '#333' },
  container: { flex: 1, backgroundColor: '#f5f5f5', paddingTop: 60 },
  title: { fontSize: 28, fontWeight: 'bold', color: '#333', paddingHorizontal: 20, marginBottom: 12 },
  
  // Contenedor principal de filtros
  filterSection: {
    paddingHorizontal: 20,
    paddingBottom: 12,
    borderBottomWidth: 1,
    borderBottomColor: '#eee',
  },
  // Contenedor solo de los chips
  filterChipContainer: {
    marginBottom: 12, // Espacio entre chips y el botón de fecha
  },
  chip: {
    paddingVertical: 8,
    paddingHorizontal: 16,
    borderRadius: 20,
    marginRight: 3, // <-- Gap reducido
    borderWidth: 1,
    flexDirection: 'row',
    alignItems: 'center',
    gap: 4,
  },
  chipActive: { backgroundColor: '#0066CC', borderColor: '#0066CC', },
  chipInactive: { backgroundColor: '#ffffff', borderColor: '#ddd', },
  chipTextActive: { color: '#ffffff', fontWeight: 'bold', },
  chipTextInactive: { color: '#555', },

  // Estilos para el botón de calendario
  datePickerButton: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'flex-end', // Alineado a la derecha
    paddingVertical: 4,
  },
  datePickerText: {
    fontSize: 14,
    color: '#555',
    marginRight: 8,
    fontWeight: '500',
  },
  // Fin de estilos de filtro

  list: {
    paddingHorizontal: 20,
    paddingBottom: 20,
  },
  sectionHeader: {
    fontSize: 18,
    fontWeight: 'bold',
    color: '#333',
    backgroundColor: '#f5f5f5', 
    paddingTop: 20,
    paddingBottom: 10,
    textTransform: 'capitalize',
  },
  entryCard: {
    backgroundColor: '#ffffff',
    borderRadius: 8,
    padding: 16,
    flexDirection: 'row',
    alignItems: 'center',
    marginBottom: 12,
    shadowColor: "#000",
    shadowOffset: { width: 0, height: 1 },
    shadowOpacity: 0.1,
    shadowRadius: 2,
    elevation: 2,
    gap: 12,
  },
  entryIcon: {
    width: 34,
    height: 34,
    resizeMode: 'contain',
    // tintColor: '#0066CC' // Descomenta si tu png es de un solo color
  },
  entryDetails: {
    flex: 1,
  },
  entryArea: {
    fontSize: 16,
    fontWeight: '500',
    color: '#333',
  },
  entryTime: {
    fontSize: 14,
    color: '#555',
    marginTop: 4,
  },
  entryPlaca: {
    fontSize: 14,
    fontWeight: '600',
    color: '#0066CC',
    backgroundColor: '#f0f5ff',
    paddingHorizontal: 8,
    paddingVertical: 4,
    borderRadius: 4,
    overflow: 'hidden',
  },
  footerButtonContainer: {
    marginVertical: 20,
  },
  footerText: {
    textAlign: 'center',
    color: '#999',
    margin: 20,
    fontSize: 14,
  },
});

HomeScreen.tsx:
import { useEffect, useState } from 'react';
import {
  StyleSheet, Text, View, ActivityIndicator,
  ScrollView, StatusBar, TouchableOpacity,
  Image // <-- 1. Importamos Image
} from 'react-native';
import ParkingService from '../services/ParkingService';
// --- 2. Importamos HistoryItem ---
import { Area, AreaStatus, PuertaStatus, HistoryItem } from '../types/entities';
import { useNavigation } from '@react-navigation/native';
import { NativeStackNavigationProp } from '@react-navigation/native-stack';
import { RootStackParamList } from '../types/navigation';
import { Ionicons } from '@expo/vector-icons';

type HomeScreenNavigationProp = NativeStackNavigationProp<RootStackParamList, 'AreaDetail'>;

// --- Funciones de estilo (no cambian) ---
const cuposText = (disponibles: boolean) => ({
  fontSize: 16, fontWeight: 'bold', color: disponibles ? '#2E8B57' : '#DC143C',
});
const statusText = (status: AreaStatus) => ({
  fontSize: 14, fontStyle: 'italic', color: status === 'OPEN' ? '#555' : '#DC143C',
  marginTop: 8, borderTopColor: '#eee', borderTopWidth: 1, paddingTop: 8,
});

// --- Componente AreaCard (no cambia) ---
function AreaCard({ area }: { area: Area }) {
  const navigation = useNavigation<HomeScreenNavigationProp>();
  const puertasDisponibles = area.puertas.filter(
    p => p.status === 'OPEN' && p.cuposOcupados < p.cuposTotales
  ).length;
  const totalPuertasAbiertas = area.puertas.filter(p => p.status === 'OPEN').length;
  const tieneDisponibilidad = puertasDisponibles > 0;

  return (
    <TouchableOpacity
      style={styles.areaCard}
      onPress={() => navigation.navigate('AreaDetail', { area: area })}
    >
      <Text style={styles.areaTitle}>{area.nombre}</Text>
      <View style={styles.cuposContainer}>
        <Ionicons 
          name={tieneDisponibilidad ? "checkmark-circle" : "close-circle"} 
          size={24} 
          color={tieneDisponibilidad ? '#2E8B57' : '#DC143C'} 
        />
        {area.status === 'OPEN' ? (
          <Text style={cuposText(tieneDisponibilidad)}>
            {puertasDisponibles} de {totalPuertasAbiertas} puertas con cupos
          </Text>
        ) : (
          <Text style={cuposText(false)}>Área Cerrada</Text>
        )}
      </View>
      {area.mensaje && (
        <Text style={statusText(area.status)}>Nota: {area.mensaje}</Text>
      )}
    </TouchableOpacity>
  );
}

// --- 3. NUEVO COMPONENTE: TARJETA DE ÚLTIMO MOVIMIENTO ---
const LatestMovementCard = ({ item }: { item: HistoryItem }) => {
  // Comprobamos si el usuario sigue estacionado
  const isCurrentlyParked = item.fechaSalida === null;
  
  return (
    <View style={styles.latestCard}>
      {/* Header de la tarjeta */}
      <View style={styles.latestHeader}>
        <Text style={styles.latestTitle}>Último Movimiento</Text>
        <View style={[
          styles.statusBadge, 
          isCurrentlyParked ? styles.statusBadgeActive : styles.statusBadgeInactive
        ]}>
          <Text style={styles.statusBadgeText}>
            {isCurrentlyParked ? "Estacionado" : "Finalizado"}
          </Text>
        </View>
      </View>

      {/* Cuerpo con el ícono y detalles */}
      <View style={styles.latestBody}>
        <Ionicons name="car-sport" size={54} color="#f8f8f8ff" />
        <View style={styles.latestDetails}>
          <Text style={styles.latestArea}>{item.area}</Text>
          <Text style={styles.latestLocation}>{item.puerta}</Text>
          <Text style={styles.latestPlaca}>{item.placa}</Text>
        </View>
      </View>

      {/* Footer con las horas */}
      <View style={styles.latestFooter}>
        <View style={styles.latestTimeBox}>
          <Text style={styles.latestTimeLabel}>Entrada</Text>
          <Text style={styles.latestTimeValue}>{item.fechaEntrada.split(' ')[1]}</Text>
          <Text style={styles.latestTimeDate}>{item.fechaEntrada.split(' ')[0]}</Text>
        </View>
        <View style={styles.latestTimeBox}>
          <Text style={styles.latestTimeLabel}>Salida</Text>
          <Text style={styles.latestTimeValue}>
            {isCurrentlyParked ? "--:--" : item.fechaSalida?.split(' ')[1]}
          </Text>
          <Text style={styles.latestTimeDate}>
            {isCurrentlyParked ? "" : item.fechaSalida?.split(' ')[0]}
          </Text>
        </View>
      </View>
    </View>
  );
};
// --- FIN DEL NUEVO COMPONENTE ---


// --- Componente Principal ---
export default function HomeScreen() {
  const [isLoading, setIsLoading] = useState(true);
  const [areas, setAreas] = useState<Area[]>([]);
  
  // --- 4. NUEVO ESTADO ---
  const [latestMovement, setLatestMovement] = useState<HistoryItem | null>(null);

  useEffect(() => {
    const loadData = async () => {
      try {
        // Cargamos los datos de las áreas y el último mov. en paralelo
        const [areasData, latestMove] = await Promise.all([
          ParkingService.getParkingStatus(),
          ParkingService.getLatestMovement()
        ]);
        
        setAreas(areasData.areas);
        setLatestMovement(latestMove);

      } catch (error) {
        console.error("Error al cargar datos:", error);
      } finally {
        setIsLoading(false);
      }
    };
    loadData();
  }, []); 

  if (isLoading) {
    return (
      <View style={styles.centerContainer}>
        <ActivityIndicator size="large" color="#0066CC" />
        <Text style={styles.loadingText}>Cargando...</Text>
      </View>
    );
  }

  return (
    <View style={styles.container}>
      <StatusBar barStyle="dark-content" />
      <Text style={styles.title}>Estacionamiento UNSA</Text>
      
      <ScrollView style={styles.list}>
        {/* --- 5. RENDERIZADO DE LA NUEVA TARJETA --- */}
        {latestMovement && (
          <LatestMovementCard item={latestMovement} />
        )}
        {/* Lista de Áreas */}
        {areas.map(area => (
          <AreaCard key={area.id} area={area} />
        ))}
      </ScrollView>
    </View>
  );
}

// --- 6. ESTILOS (ACTUALIZADOS) ---
const styles = StyleSheet.create({
  centerContainer: { flex: 1, justifyContent: 'center', alignItems: 'center', backgroundColor: '#f5f5f5' },
  loadingText: { marginTop: 10, fontSize: 16, color: '#333' },
  container: { flex: 1, backgroundColor: '#f5f5f5', paddingTop: 60 },
  title: { fontSize: 28, fontWeight: 'bold', color: '#333', paddingHorizontal: 20, marginBottom: 20 },
  list: { paddingHorizontal: 20 },
  areaCard: {
    backgroundColor: '#ffffff',
    borderRadius: 12,
    padding: 20,
    marginBottom: 16,
    shadowColor: "#000",
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.1,
    shadowRadius: 4,
    elevation: 3,
  },
  areaTitle: { fontSize: 20, fontWeight: '600', color: '#0066CC', marginBottom: 12 },
  cuposContainer: { flexDirection: 'row', alignItems: 'center', gap: 8, marginBottom: 4, },

  // --- 7. NUEVOS ESTILOS PARA LA TARJETA "ÚLTIMO MOVIMIENTO" ---
  latestCard: {
    backgroundColor: '#0066CC', // Color de acento principal
    borderRadius: 12,
    padding: 20,
    marginBottom: 20, // Espacio al final de la lista
  },
  latestHeader: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    borderBottomWidth: 1,
    borderBottomColor: 'rgba(255, 255, 255, 0.3)',
    paddingBottom: 12,
  },
  latestTitle: {
    fontSize: 18,
    fontWeight: 'bold',
    color: '#ffffff',
  },
  statusBadge: {
    paddingVertical: 4,
    paddingHorizontal: 10,
    borderRadius: 12,
  },
  statusBadgeActive: {
    backgroundColor: 'rgba(46, 204, 113, 0.8)', // Verde
  },
  statusBadgeInactive: {
    backgroundColor: 'rgba(255, 255, 255, 0.3)', // Gris
  },
  statusBadgeText: {
    color: '#ffffff',
    fontWeight: '600',
    fontSize: 12,
  },
  latestBody: {
    flexDirection: 'row',
    alignItems: 'center',
    paddingVertical: 20,
    gap: 16,
  },
  latestCarIcon: {
    width: 48,
    height: 48,
    resizeMode: 'contain',
    tintColor: '#ffffff' // Tiñe el carro de blanco
  },
  latestDetails: {
    flex: 1,
  },
  latestArea: {
    fontSize: 18,
    fontWeight: 'bold',
    color: '#ffffff',
  },
  latestLocation: {
    fontSize: 14,
    color: '#f0f5ff',
  },
  latestPlaca: {
    fontSize: 16,
    fontWeight: '600',
    color: '#0066CC',
    backgroundColor: '#ffffff',
    paddingHorizontal: 8,
    paddingVertical: 4,
    borderRadius: 4,
    overflow: 'hidden',
    marginTop: 8,
    alignSelf: 'flex-start', // Para que no ocupe toda la línea
  },
  latestFooter: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    borderTopWidth: 1,
    borderTopColor: 'rgba(255, 255, 255, 0.3)',
    paddingTop: 12,
  },
  latestTimeBox: {
    alignItems: 'center',
    flex: 1,
  },
  latestTimeLabel: {
    fontSize: 12,
    color: '#f0f5ff',
    textTransform: 'uppercase',
  },
  latestTimeValue: {
    fontSize: 20,
    fontWeight: 'bold',
    color: '#ffffff',
    marginVertical: 2,
  },
  latestTimeDate: {
    fontSize: 12,
    color: '#f0f5ff',
  },
});

LoginScreen.tsx:
import React, { useState } from 'react';
import { 
  View, Text, TextInput, Button, StyleSheet, 
  TouchableOpacity, ActivityIndicator, Alert, KeyboardAvoidingView, Platform
} from 'react-native';
import ParkingService from '../services/ParkingService'; // Importamos el servicio
import { Ionicons } from '@expo/vector-icons'; // Para el ícono

// Simulación de 'props' de navegación
type LoginScreenProps = {
  onLogin: () => void; // Función que pasaremos para "iniciar sesión"
};

export default function LoginScreen({ onLogin }: LoginScreenProps) {
  // Estados para guardar los datos del formulario
  const [email, setEmail] = useState('');
  const [password, setPassword] = useState('');
  
  // Estado para mostrar un "cargando..." mientras validamos
  const [isLoading, setIsLoading] = useState(false);
  const [isPasswordVisible, setIsPasswordVisible] = useState(false);
  // Función que se llama al presionar "Ingresar"
  const handleLoginPress = async () => {
    if (!email || !password) {
      Alert.alert('Error', 'Por favor, ingrese su correo y contraseña.');
      return;
    }

    setIsLoading(true); // Mostrar "cargando"

    try {
      // Llamamos a nuestra API simulada
      const exito = await ParkingService.login(email, password);

      if (exito) {
        // Si el login es exitoso, llamamos a la función onLogin
        // que nos pasó App.tsx para cambiar de pantalla.
        onLogin();
      } else {
        // Si no, mostramos un error
        Alert.alert('Error', 'Correo o contraseña incorrectos.');
      }
    } catch (error) {
      Alert.alert('Error', 'Ocurrió un problema de conexión.');
    } finally {
      setIsLoading(false); // Ocultar "cargando"
    }
  };

  const togglePasswordVisibility = () => {
    setIsPasswordVisible(!isPasswordVisible);
  };

  return (
    // KeyboardAvoidingView evita que el teclado tape los inputs
    <KeyboardAvoidingView 
      behavior={Platform.OS === "ios" ? "padding" : "height"}
      style={styles.container}
    >
      <View style={styles.logoContainer}>
        <Ionicons name="car-sport" size={64} color="#0066CC" />
        <Text style={styles.title}>UNSA Park</Text>
        <Text style={styles.subtitle}>Gestión de Estacionamiento</Text>
      </View>

      <View style={styles.formContainer}>
        <TextInput
          style={styles.input}
          placeholder="Correo Electrónico"
          value={email}
          onChangeText={setEmail} // Actualiza el estado 'email'
          keyboardType="email-address" // Muestra teclado para email
          autoCapitalize="none" // Desactiva mayúsculas automáticas
          autoCorrect={false}
        />
        <View style={styles.passwordContainer}>
          <TextInput
            style={styles.inputPassword}
            placeholder="Contraseña"
            value={password}
            onChangeText={setPassword}
            // El 'secureTextEntry' ahora depende del estado
            secureTextEntry={!isPasswordVisible}
          />
          <TouchableOpacity 
            style={styles.eyeIcon} 
            onPress={togglePasswordVisibility}
          >
            <Ionicons 
              // Cambia el ícono dependiendo del estado
              name={isPasswordVisible ? 'eye-off' : 'eye'} 
              size={24} 
              color="#555" 
            />
          </TouchableOpacity>
        </View>

        {/* Usamos un TouchableOpacity para un botón más bonito */}
        <TouchableOpacity 
          style={styles.button} 
          onPress={handleLoginPress}
          disabled={isLoading} // Deshabilita el botón si está cargando
        >
          {isLoading ? (
            <ActivityIndicator color="#ffffff" />
          ) : (
            <Text style={styles.buttonText}>Ingresar</Text>
          )}
        </TouchableOpacity>
      </View>
    </KeyboardAvoidingView>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    justifyContent: 'center',
    backgroundColor: '#f5f5f5',
    padding: 20,
  },
  logoContainer: {
    alignItems: 'center',
    marginBottom: 40,
  },
  title: {
    fontSize: 32,
    fontWeight: 'bold',
    color: '#0066CC',
    marginTop: 16,
  },
  subtitle: {
    fontSize: 18,
    color: '#555',
  },
  formContainer: {
    width: '100%',
  },
  input: {
    backgroundColor: '#ffffff',
    paddingHorizontal: 16,
    paddingVertical: 12,
    borderRadius: 8,
    borderWidth: 1,
    borderColor: '#ddd',
    fontSize: 16,
    marginBottom: 16,
  },
  passwordContainer: {
    flexDirection: 'row',
    alignItems: 'center',
    backgroundColor: '#ffffff',
    borderRadius: 8,
    borderWidth: 1,
    borderColor: '#ddd',
    marginBottom: 16,
  },
  inputPassword: {
    flex: 1, // El input toma todo el espacio
    paddingHorizontal: 16, 
    paddingVertical: 12, 
    fontSize: 16,
  },
  eyeIcon: {
    padding: 12, // Área táctil para el ícono
  },
  button: {
    backgroundColor: '#0066CC',
    padding: 16,
    borderRadius: 8,
    alignItems: 'center',
    marginTop: 8,
  },
  buttonText: {
    color: '#ffffff',
    fontSize: 16,
    fontWeight: 'bold',
  },
});

PerfilScreen.tsx:
import React, { useState, useEffect } from 'react';
import { 
  View, Text, StyleSheet, Button, 
  ActivityIndicator, ScrollView, StatusBar 
} from 'react-native';
import ParkingService from '../services/ParkingService';
import { UserProfile, Vehiculo } from '../types/entities';
import { Ionicons } from '@expo/vector-icons';

// Props que recibe (ya teníamos 'onLogout')
type PerfilScreenProps = {
  onLogout: () => void;
};

// --- Componentes de UI Pequeños ---
// Para mostrar una fila de información (Ej: DNI: 12345678)
const InfoRow = ({ label, value }: { label: string, value: string }) => (
  <View style={styles.infoRow}>
    <Text style={styles.infoLabel}>{label}</Text>
    <Text style={styles.infoValue}>{value}</Text>
  </View>
);

// Para mostrar la tarjeta de un vehículo
const VehiculoCard = ({ vehiculo }: { vehiculo: Vehiculo }) => (
  <View style={styles.vehiculoCard}>
    <Ionicons name="car-sport" size={24} color="#0066CC" />
    <View style={styles.vehiculoInfo}>
      <Text style={styles.vehiculoPlaca}>{vehiculo.placa}</Text>
      <Text style={styles.vehiculoModelo}>{vehiculo.modelo}</Text>
    </View>
  </View>
);
// --- Fin de Componentes UI ---


export default function PerfilScreen({ onLogout }: PerfilScreenProps) {
  const [isLoading, setIsLoading] = useState(true);
  const [profile, setProfile] = useState<UserProfile | null>(null);

  useEffect(() => {
    const loadProfile = async () => {
      try {
        const data = await ParkingService.getUserProfile();
        setProfile(data);
      } catch (error) {
        console.error("Error cargando perfil:", error);
      } finally {
        setIsLoading(false);
      }
    };
    loadProfile();
  }, []);

  // Pantalla de Carga
  if (isLoading) {
    return (
      <View style={styles.centerContainer}>
        <ActivityIndicator size="large" color="#0066CC" />
      </View>
    );
  }

  // Pantalla de Error (si el perfil no cargó)
  if (!profile) {
    return (
      <View style={styles.centerContainer}>
        <Text>Error al cargar el perfil.</Text>
        <View style={styles.logoutButtonContainer}>
          <Button title="Cerrar Sesión" onPress={onLogout} color="#DC143C" />
        </View>
      </View>
    );
  }

  // Pantalla de Perfil Cargado
  return (
    <ScrollView style={styles.container}>
      <StatusBar barStyle="dark-content" />
      
      {/* Header del Perfil */}
      <View style={styles.header}>
        <View style={styles.avatar}>
          <Ionicons name="person-circle" size={80} color="#0066CC" />
        </View>
        <Text style={styles.name}>{profile.nombreCompleto}</Text>
        <Text style={styles.email}>{profile.email}</Text>
        <Text style={styles.dni}>DNI: {profile.dni}</Text>
      </View>

      {/* Sección de Información Académica */}
      <View style={styles.section}>
        <Text style={styles.sectionTitle}>Información Académica</Text>
        <View style={styles.card}>
          <InfoRow label="Tipo de Usuario" value={profile.tipoUsuario} />
          <InfoRow label="Código" value={profile.codigo} />
          <InfoRow label="Escuela Profesional" value={profile.escuela} />
        </View>
      </View>

      {/* Sección de Vehículos */}
      <View style={styles.section}>
        <Text style={styles.sectionTitle}>Vehículos Registrados</Text>
        {profile.vehiculos.map(v => (
          <VehiculoCard key={v.placa} vehiculo={v} />
        ))}
      </View>

      {/* Botón de Logout */}
      <View style={styles.logoutButtonContainer}>
        <Button title="Cerrar Sesión" onPress={onLogout} color="#DC143C" />
      </View>
    </ScrollView>
  );
}

// --- Estilos ---
const styles = StyleSheet.create({
  centerContainer: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    backgroundColor: '#f5f5f5',
  },
  container: {
    flex: 1,
    backgroundColor: '#f5f5f5',
  },
  header: {
    backgroundColor: '#ffffff',
    paddingVertical: 24,
    alignItems: 'center',
    borderBottomWidth: 1,
    borderBottomColor: '#eee',
    marginBottom: 20,
  },
  avatar: {
    marginBottom: 8,
  },
  name: {
    fontSize: 22,
    fontWeight: 'bold',
    color: '#333',
  },
  email: { // <-- AÑADIDO
    fontSize: 16,
    color: '#0066CC', // Color de acento
    marginTop: 4,
  },
  dni: {
    fontSize: 16,
    color: '#555',
    marginTop: 4,
  },
  section: {
    paddingHorizontal: 20,
    marginBottom: 20,
  },
  sectionTitle: {
    fontSize: 18,
    fontWeight: '600',
    color: '#333',
    marginBottom: 12,
  },
  card: {
    backgroundColor: '#ffffff',
    borderRadius: 8,
    padding: 16,
    shadowColor: "#000",
    shadowOffset: { width: 0, height: 1 },
    shadowOpacity: 0.05,
    shadowRadius: 2,
    elevation: 1,
  },
  infoRow: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    paddingVertical: 12,
    borderBottomWidth: 1,
    borderBottomColor: '#f0f0f0',
  },
  infoLabel: {
    fontSize: 14,
    color: '#555',
  },
  infoValue: {
    fontSize: 14,
    fontWeight: '500',
    color: '#333',
    maxWidth: '60%', // Evita que el texto largo se desborde
  },
  vehiculoCard: {
    backgroundColor: '#ffffff',
    borderRadius: 8,
    padding: 16,
    flexDirection: 'row',
    alignItems: 'center',
    gap: 16,
    marginBottom: 12,
    shadowColor: "#000",
    shadowOffset: { width: 0, height: 1 },
    shadowOpacity: 0.05,
    shadowRadius: 2,
    elevation: 1,
  },
  vehiculoInfo: {
    flex: 1,
  },
  vehiculoPlaca: {
    fontSize: 16,
    fontWeight: 'bold',
    color: '#333',
  },
  vehiculoModelo: {
    fontSize: 14,
    color: '#555',
  },
  logoutButtonContainer: {
    padding: 20,
    paddingBottom: 30, // Espacio extra al final
  },
});

RouteMapScreen.tsx:
import React, { useState, useEffect } from 'react';
import { View, Text, StyleSheet, ActivityIndicator, Alert } from 'react-native';
import MapView, { Marker, PROVIDER_GOOGLE } from 'react-native-maps';
import { useRoute } from '@react-navigation/native';
import { Puerta } from '../types/entities';
import * as Location from 'expo-location'; // Para la ubicación del usuario
import MapViewDirections from 'react-native-maps-directions'; // Para la ruta

// La clave de API desde el .env
const GOOGLE_MAPS_API_KEY = process.env.EXPO_PUBLIC_GOOGLE_MAPS_API_KEY;

type Coords = {
  latitude: number;
  longitude: number;
};

// --- FUNCIÓN DE ESTILO (CORREGIDA) ---
// La movemos aquí AFUERA del StyleSheet
const infoStatus = (disponible: boolean) => ({
  fontSize: 16,
  color: disponible ? '#2E8B57' : '#DC143C', // Verde o Rojo
  fontWeight: 'bold',
  marginTop: 4,
});
// --- FIN DE LA CORRECCIÓN ---


export default function RouteMapScreen() {
  const route = useRoute();
  // @ts-ignore
  const { puerta } = route.params as { puerta: Puerta };

  const [origin, setOrigin] = useState<Coords | null>(null);
  const [isLoading, setIsLoading] = useState(true);
  const [errorMsg, setErrorMsg] = useState<string | null>(null);

  // 1. Pedir permiso y obtener ubicación
  useEffect(() => {
    (async () => {
      let { status } = await Location.requestForegroundPermissionsAsync();
      if (status !== 'granted') {
        setErrorMsg('Permiso de ubicación denegado');
        setIsLoading(false);
        Alert.alert('Permiso denegado', 'No podemos trazar la ruta sin tu ubicación.');
        return;
      }

      let location = await Location.getCurrentPositionAsync({});
      setOrigin({
        latitude: location.coords.latitude,
        longitude: location.coords.longitude,
      });
      setIsLoading(false);
    })();
  }, []);

  const destination = {
    latitude: puerta.latitude,
    longitude: puerta.longitude,
  };

  // Calculamos la disponibilidad de la puerta
  const disponibles = puerta.cuposTotales - puerta.cuposOcupados;
  const hasCupos = disponibles > 0;

  // Pantalla de carga
  if (isLoading) {
    return (
      <View style={styles.centerContainer}>
        <ActivityIndicator size="large" color="#0066CC" />
        <Text style={styles.loadingText}>Obteniendo tu ubicación...</Text>
      </View>
    );
  }

  // Pantalla de error
  if (errorMsg || !origin) {
    return (
      <View style={styles.centerContainer}>
        <Text style={styles.loadingText}>{errorMsg || 'No se pudo obtener la ubicación.'}</Text>
      </View>
    );
  }

  // Pantalla con el Mapa y la Ruta
  return (
    <View style={styles.container}>
      <MapView
        style={styles.map}
        provider={PROVIDER_GOOGLE}
        initialRegion={{
          ...origin,
          latitudeDelta: 0.0922,
          longitudeDelta: 0.0421,
        }}
      >
        <MapViewDirections
          origin={origin}
          destination={destination}
          apikey={GOOGLE_MAPS_API_KEY}
          strokeWidth={4}
          strokeColor="red"
          onError={(error) => console.log('Directions error: ', error)}
        />
        <Marker coordinate={origin} title="Tu Ubicación" pinColor="blue" />
        <Marker coordinate={destination} title={puerta.nombre} />
      </MapView>

      <View style={styles.infoBox}>
        <Text style={styles.infoTitle}>Ruta a: {puerta.nombre}</Text>
        
        {/* --- CORRECCIÓN DE LLAMADA --- */}
        {/* Se llama a la función 'infoStatus' (sin styles.) 
            y le pasamos la variable 'hasCupos' */}
        <Text style={infoStatus(hasCupos)}>
          Cupos: {disponibles} / {puerta.cuposTotales}
        </Text>
        
      </View>
    </View>
  );
}

const styles = StyleSheet.create({
  container: { flex: 1 },
  centerContainer: { flex: 1, justifyContent: 'center', alignItems: 'center' },
  loadingText: { fontSize: 16, marginTop: 10 },
  map: { flex: 1 },
  infoBox: {
    position: 'absolute',
    bottom: 20,
    left: 20,
    right: 20,
    backgroundColor: 'white',
    padding: 16,
    borderRadius: 12,
    shadowColor: "#000",
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.2,
    shadowRadius: 4,
    elevation: 5,
  },
  infoTitle: {
    fontSize: 18,
    fontWeight: 'bold',
    color: '#333',
  },
  // 'infoStatus' ya no está aquí
});

ParkingService.ts:
import {
  ParkingStatusResponse,
  Area,
  HistoryItem,
  UserProfile,
  Vehiculo
} from '../types/entities';

// --- ESTOS SON TUS DATOS ESTÁTICOS ---
const MOCK_AREAS: Area[] = [
  {
    id: "ing",
    nombre: "Área Ingenierías",
    status: "OPEN",
    mensaje: "",
    latitude: -16.404767,
    longitude: -71.525237,
    latitudeDelta: 0.005,
    longitudeDelta: 0.005,
    puertas: [
      { id: "ing_pauc", nombre: "Puerta Paucarpata", status: "OPEN", latitude: -16.404937, longitude: -71.526682, cuposTotales: 30, cuposOcupados: 12 },
      { id: "ing_inde", nombre: "Puerta Independencia", status: "OPEN", latitude: -16.403070, longitude: -71.525817, cuposTotales: 30, cuposOcupados: 28 }, // Casi llena
      { id: "ing_vene", nombre: "Puerta Venezuela", status: "MAINTENANCE", latitude: -16.406396, longitude: -71.523213, cuposTotales: 30, cuposOcupados: 0 } // Cerrada
    ]
  },
  {
    id: "soc",
    nombre: "Área Sociales",
    status: "OPEN",
    mensaje: "Pocos cupos disponibles",
    latitude: -16.405293,
    longitude: -71.520728,
    latitudeDelta: 0.003,
    longitudeDelta: 0.003,
    puertas: [
      { id: "soc_virg", nombre: "Puerta Virgen del Pilar", status: "OPEN", latitude: -16.405293, longitude: -71.520728, cuposTotales: 30, cuposOcupados: 30 } // Llena
    ]
  },
  {
    id: "bio",
    nombre: "Área Biomédicas",
    status: "CLOSED",
    mensaje: "Cerrado por domingo",
    latitude: -16.413125,
    longitude: -71.534364,
    latitudeDelta: 0.004,
    longitudeDelta: 0.004,
    puertas: [
      { id: "bio_virg", nombre: "Puerta Virgen del Pilar", status: "CLOSED", latitude: -16.411713, longitude: -71.534411, cuposTotales: 30, cuposOcupados: 0 },
      { id: "bio_alc", nombre: "Puerta Daniel Alcides", status: "CLOSED", latitude: -16.414537, longitude: -71.534316, cuposTotales: 30, cuposOcupados: 0 }
    ]
  }
];
// --- FIN DE DATOS ESTÁTICOS ---

// --- MOCK HISTORIAL ---
const ALL_MOCK_HISTORY: HistoryItem[] = [
  { id: "1", area: "Ingenierías", puerta: "Puerta Paucarpata", placa: "V1X-234", fechaEntrada: "2025-11-11 14:30", fechaSalida: null },
  { id: "2", area: "Sociales", puerta: "Virgen del Pilar", placa: "V1X-234", fechaEntrada: "2025-11-10 09:15", fechaSalida: "2025-11-10 11:20" },
  { id: "3", area: "Biomédicas", puerta: "Daniel Alcides", placa: "A9B-567", fechaEntrada: "2025-11-09 11:00", fechaSalida: "2025-11-09 13:00" },
  { id: "4", area: "Ingenierías", puerta: "Independencia", placa: "V1X-234", fechaEntrada: "2025-11-09 08:00", fechaSalida: "2025-11-09 10:30" },
  { id: "5", area: "Ingenierías", puerta: "Paucarpata", placa: "V1X-234", fechaEntrada: "2025-11-07 10:00", fechaSalida: "2025-11-07 12:00" },
  { id: "6", area: "Sociales", puerta: "Virgen del Pilar", placa: "A9B-567", fechaEntrada: "2025-11-07 09:30", fechaSalida: "2025-11-07 11:30" },
  { id: "7", area: "Biomédicas", puerta: "Virgen del Pilar", placa: "V1X-234", fechaEntrada: "2025-11-05 15:00", fechaSalida: "2025-11-05 17:00" },
  { id: "8", area: "Ingenierías", puerta: "Venezuela", placa: "V1X-234", fechaEntrada: "2025-11-05 10:10", fechaSalida: "2025-11-05 12:00" },
  { id: "9", area: "Sociales", puerta: "Virgen del Pilar", placa: "A9B-567", fechaEntrada: "2025-11-04 09:00", fechaSalida: "2025-11-04 18:00" },
  { id: "10", area: "Ingenierías", puerta: "Paucarpata", placa: "V1X-234", fechaEntrada: "2025-11-01 10:00", fechaSalida: "2025-11-01 12:00" },
];

// --- MOCK PERFIL ---
const MOCK_USER_PROFILE: UserProfile = {
  id: "u1",
  nombreCompleto: "Juan Pérez García",
  email: "correo@gmail.com",
  dni: "12345678",
  tipoUsuario: "Estudiante",
  codigo: "2020-12345",
  escuela: "Ingeniería de Sistemas",
  vehiculos: [
    { placa: "V1X-234", modelo: "Toyota Corolla" },
    { placa: "A9B-567", modelo: "Honda Civic" }
  ]
};

// --- FUNCIONES DEL SERVICIO ---

const getParkingStatus = (): Promise<ParkingStatusResponse> => {
  return new Promise(resolve => {
    setTimeout(() => {
      resolve({ areas: MOCK_AREAS });
    }, 500);
  });
};

const login = (email: string, password: string): Promise<boolean> => {
  return new Promise(resolve => {
    setTimeout(() => {
      // Lógica de simulación actualizada:
      const loginExitoso = (
        email.toLowerCase() === "correo@gmail.com" && 
        password === "contraseña123"
      );
      resolve(loginExitoso);
    }, 1000);
  });
};

// Definimos los tipos de filtro
type HistoryFilter = 'today' | 'week' | 'month'| 'all';
// --- 2. ACTUALIZAMOS getUserHistory PARA PAGINACIÓN ---
const PAGE_SIZE = 5; // Diremos que nuestra API devuelve 5 items a la vez

/**
 * Simula la obtención del historial de un usuario, por páginas y con filtro.
 */
const getUserHistory = (
  page: number = 1,
  // El filtro puede ser un string o una fecha específica
  filter: HistoryFilter | Date = 'all'
): Promise<HistoryItem[]> => {
  
  return new Promise(resolve => {
    setTimeout(() => {
      // --- 1. Usamos la fecha real del sistema ---
      const now = new Date(); 
      // NOTA: Para probar con tus datos MOCK, temporalmente cambia 'now' por:
      // const now = new Date('2025-11-10T10:00:00');

      const filteredHistory = ALL_MOCK_HISTORY.filter(item => {
        const itemDate = new Date(item.fechaEntrada);
        
        // --- 2. Lógica de Filtro Actualizada ---
        if (filter === 'all') {
          return true; // No filtra nada, devuelve todos
        }
        if (filter instanceof Date) {
          // Filtro de calendario: compara solo el día
          return itemDate.toDateString() === filter.toDateString();
        }
        if (filter === 'today') {
          return itemDate.toDateString() === now.toDateString();
        }
        if (filter === 'week') {
          const lastWeek = new Date(now);
          lastWeek.setDate(now.getDate() - 7);
          // Aseguramos que solo cuente hasta "hoy"
          return itemDate >= lastWeek && itemDate <= now;
        }
        if (filter === 'month') {
          return itemDate.getMonth() === now.getMonth() && 
                 itemDate.getFullYear() === now.getFullYear();
        }
        return true;
      });
      // --- Fin Lógica de Filtro ---

      const start = (page - 1) * PAGE_SIZE;
      const end = page * PAGE_SIZE;
      resolve(filteredHistory.slice(start, end));
    }, 700);
  });
};

const getUserProfile = (): Promise<UserProfile> => {
  return new Promise(resolve => {
    setTimeout(() => {
      resolve(MOCK_USER_PROFILE);
    }, 300);
  });
};
// --- 2. NUEVA FUNCIÓN ---
/**
 * Simula la obtención del último movimiento (esté activo o finalizado)
 */
const getLatestMovement = (): Promise<HistoryItem | null> => {
  return new Promise(resolve => {
    // Retraso corto
    setTimeout(() => {
      if (ALL_MOCK_HISTORY.length > 0) {
        resolve(ALL_MOCK_HISTORY[0]); // Devuelve el item más reciente
      } else {
        resolve(null);
      }
    }, 400); 
  });
};
// --- FIN NUEVA FUNCIÓN ---

// --- EXPORTACIÓN ---
const ParkingService = {
  getParkingStatus,
  login,
  getUserHistory,
  getUserProfile,
  getLatestMovement,
};

export default ParkingService;

entities.ts:
export type PuertaStatus = "OPEN" | "CLOSED" | "MAINTENANCE";
export type AreaStatus = "OPEN" | "CLOSED" | "FULL" | "EVENT";

export interface Puerta {
  id: string;
  nombre: string;
  status: PuertaStatus;
  latitude: number;
  longitude: number;
  cuposTotales: number;  
  cuposOcupados: number; 
}

export interface Area {
  id: string;
  nombre: string;
  status: AreaStatus;
  mensaje: string; 
  puertas: Puerta[];
  
  // --- cuposTotales y cuposOcupados se han ELIMINADO de aquí ---
  
  // Coordenadas para centrar el mapa
  latitude: number;
  longitude: number;
  latitudeDelta: number;
  longitudeDelta: number;
}

// ... (El resto del archivo: ParkingStatusResponse, HistoryItem, UserProfile, etc. no cambia)
export interface ParkingStatusResponse {
  areas: Area[];
}
export interface HistoryItem {
  id: string;
  area: string;
  puerta: string;
  placa: string;
  fechaEntrada: string;
  fechaSalida: string | null;
}
export interface Vehiculo {
  placa: string;
  modelo: string;
}
export interface UserProfile {
  id: string;
  nombreCompleto: string;
  email: string;
  dni: string;
  tipoUsuario: string;
  codigo: string;
  escuela: string;
  vehiculos: Vehiculo[];
}

navigation.ts:
import { Area, Puerta } from './entities'; // Importamos el tipo 'Area'

/**
 * Esta es la lista de todas las pantallas en nuestro Stack.Navigator
 * y los parámetros que cada una espera.
 * * 'undefined' significa que no espera parámetros.
 */
export type RootStackParamList = {
  Login: undefined;
  MainApp: undefined; // Esta es la pantalla que contiene las PESTAÑAS
  AreaDetail: { area: Area }; // Esta pantalla REQUIERE un objeto 'area';
  RouteMap: { puerta: Puerta };
};